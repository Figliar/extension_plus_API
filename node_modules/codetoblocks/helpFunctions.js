/**
 * Author: René Rešetár
 * Email: xreset00@stud.fit.vutbr.cz
 *
 * This file contains all the helper functions used in processing the tree.
 */

/**
 * Lists input names and field names of a Blockly block.
 * @param {Blockly.Block} block The block to list input and field names for.
 */
function listInputNames(block){
    console.debug("Inputs for block: ", block.type);
    block.inputList.forEach(function(input) {
        console.debug("Input Name: ", input.name);
        input.fieldRow.forEach(function(field){
            console.debug("Field Name: ", field.name);
        })
    });
    console.debug("------------ END OF LISTING ------------");
}

/**
 * Retrieves parameters from the given node.
 * @param {Node} node The node to retrieve parameters from.
 * @returns {Node[]|null} An array of parameters if found, otherwise null.
 */
function getParameters(node){
    if (node.childCount === 0){
        return null;
    }
    let array = [];
    for(const child of node.children){
        if (child.text !== ',' && child.text !== '(' && child.text !== ')'){
            array.push(child);
        }
    }
    return array;
}


/**
 * Resets the Blockly workspace by removing all blocks.
 * @param {Blockly.Workspace} workspace The workspace to reset.
 */
function reset_workspace(workspace){
    var blocks = workspace.getTopBlocks();
    blocks.forEach(function(block){
        block.dispose();
    });
    workspace.cleanUp();
}



function traverse(node, errorNodes) {
    if (node.type === 'ERROR' || node.toString().includes("MISSING")){
        errorNodes.push(node);
    }
    // Recursively traverse child nodes
    for (const childNode of node.children) {
        traverse(childNode, errorNodes);
    }
}

function getErrors(tree) {
    const variableNames = [];
    traverse(tree.rootNode, variableNames);
    return variableNames;
}


/**
 * Creates Blockly code based on the tree received from tree-sitter.
 * @param {Node} root_node The root node of the tree.
 * @param {Distributor} distributor The main distributor which stores important info
 * @param {string} bodySetter The setter for the body of the block. null for main block
 * @param {Blockly.Block|null} firstInnerBlock The first inner block of inner statement. null for main block.
 * @returns {boolean} Returns true.
 */
export function createBlocklyCode(root_node, distributor , bodySetter, firstInnerBlock ){
    let tempBlock; // Variable to store temporary block
    let lastBlock = null; // Variable to store the last block created
    let statementConnection; // Variable to store statement connection
    let isInner = firstInnerBlock !== null; // Check if it's an inner block

    // Iterate through the nodes of the tree
    for (const node of root_node.children) {
        console.log(node.text);
        // Get node handler from distributor and create block
        const nodeHandler = distributor.getNodeObject(node, lastBlock);
        if (nodeHandler instanceof CommentNode && !isInner){
            // Ignore comments in the main body to avoid infinite loop of generating comments for functions
            continue
        }
        tempBlock = nodeHandler.createBlock();

        // Deal with connecting the blocks or moving the new block from last one
        if (isInner){
            if (firstInnerBlock !== null && tempBlock !== null) {
                statementConnection = firstInnerBlock.getInput(bodySetter).connection;
                statementConnection.connect(tempBlock.previousConnection);
                firstInnerBlock = null;
            }
            else if (tempBlock !== null && lastBlock !== null) {
                tempBlock.previousConnection.connect(lastBlock.nextConnection);
            }
        }
        else if (lastBlock !== null){
            if (node.previousSibling.type === 'empty_line'
                || node.type === 'function_definition_statement'
                || node.previousSibling.type === 'function_definition_statement') {
                if (tempBlock !== lastBlock) {
                    let blockPosition = lastBlock.getRelativeToSurfaceXY();
                    tempBlock.moveBy(blockPosition.x + 0, blockPosition.y + lastBlock.height + 30);
                }
            }
            else if (lastBlock.type !== 'procedures_defnoreturn' || lastBlock.type !== 'procedures_defreturn')
                tempBlock.previousConnection.connect(lastBlock.nextConnection);
        }
        lastBlock = tempBlock; // Update last block
    }
    return true; // Return true after it is finished
}
